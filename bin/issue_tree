#!/usr/local/bin/ruby -w

require 'optparse'
require 'zenhub_ruby'
require 'zenhub_ruby/issue'
require 'yaml'

def auth_info(file)
  begin
    result = YAML.load_file(file)
  rescue => detail
    puts "Could not read auth file #{file}: #{detail}"
    exit 1
  end

  fail "Must provide zenhub auth token" unless result['zenhub']
  fail "Must provide github auth token" unless result['github']

  result
end

options = {
  :auth_file => File.expand_path("~/etc/zenhub/auth.yaml")
}

option_parser = OptionParser.new do |parser|
	parser.banner = "Usage: template.rb [options]"

  parser.on("-a", "--auth") do |file|
    options[:auth_file] = file
  end

  parser.on("-h", "--help", "Print program help") do
      puts parser.help
      exit(0)
  end
end

option_parser.parse!

unless options.empty?
  # Do something with the options
end

repository = ARGV.shift or raise "Must specify repository to query"

auth = auth_info(options[:auth_file])
client = ZenhubRuby::Client.new(auth['zenhub'], auth['github'])

# This is the graph that contains everything.
issues = ZenhubRuby::Issue::Collection.new

# Get the epics first
result = client.epics(repository)

epics = []

result["epic_issues"].each do |hash|
  hash[:is_epic] = true
  issue = ZenhubRuby::Issue.new(hash)
  epics << issue
  issues.add(issue)
end

# Then get the epic data
epics.each do |epic|
  result = client.epic_data(repository, epic.issue_number)

  result["issues"].each do |hash|
    issue = ZenhubRuby::Issue.new(hash)
    issues.add(issue)

    # Create an edge between the issue and the epic.
    # We're kind of cheating here, because the system doesn't model this
    # as 'blocking', but it's fine for this case.
    epic.blocked_by(issue)
    issue.blocking(epic)
  end
end

# Then the dependencies
result = client.dependencies(repository)

result["dependencies"].each do |hash|
  blocking_name = ZenhubRuby::Issue.name_from_hash(hash["blocking"])
  blocked_name = ZenhubRuby::Issue.name_from_hash(hash["blocked"])

  unless blocking = issues[blocking_name]
    blocking = ZenhubRuby::Issue.new(hash["blocking"])
    issues.add(blocking)
  end
  unless blocked = issues[blocked_name]
    blocked = ZenhubRuby::Issue.new(hash["blocked"])
    issues.add(blocked)
  end

  blocked.blocked_by(blocking)
  blocking.blocking(blocked)
end

# XXX Next step is to get the complete issue list
# And maybe print the issue name after the number?
issues.print_tree
